<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
		//1.作用域
		/*	let a=2;
			if(true){
				let b=1;
				console.log(b);
			}
				console.log(a);
				console.log(b);
		*/
		
		//2.for循环的计数器，就很合适使用let命令
		/*for(let i = 0; i < 6; i++){
			console.log(i);
		}
			console.log(i);
		*/
		/*var a= [];
		for(var i=0;i<10;i++){
			a[i] = function(){
				console.log(i);
			}
		}
		for(let i=0;i<10;i++){
			a[i] = function(){
				console.log(i);
			}
		}
		a[6]();
		*/
		
		
		// 2.1.2 let不想var 那样会发生“变量提升”现象。所以变量一定要在声明后使用，否则报错、
		/*console.log(foo);	// 输出underfined 
		console.log(bar);	//报错ReferenceError
		
		var foo = 2;
		let bar = 2;
		
		上面代码中，变量foo用var 命令声明，会发生变量提升，即脚本开始运行。变量foo已经存在了。，但是没有值
		所以会输出underfined。变量bar用let命令声明。不会发生变量提升。这表明在声明它之前。变量bar是不存在的。这时如果用到它。就会抛出一个错误、
		
		*/
		
		//2.1.3 暂时性死区
		/*只要块级作用域内存在let命令,它所声明的变量就"绑定"(binding)这个区域,不再受外部的影响.
		
		
		var tmp = 123;
		if(true){
			tmp ='abc';
			let tmp;
		}
		
		上面代码中，存在全局变量tmp.但是块级作用域内let又声明了一个全局变量tmp.导致后者绑定这个块级作用域，
		所以在let声明变量前，对tmp赋值会报错。
		ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域、
		凡是声明之前就使用这些变量，就会报错。
		
		总之，在代码块内，使用let命令声明变量之前，改变量都是不可用的。这在语法上称为“暂时性死区”
		暂时性死区 也意味着typeof不再是一个百分之百安全的操作
		
		
		function bar(x = y; y=2){
			return [x,y];
		}
		bar();function bar(x = y; y=2){
			return [x,y];
		}
		bar();
		暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到变量声明的
		那一行代码出现，才可以获取和使用该变量。
		*/
		
		//2.1.4 不允许重复声明
		/*
		 let不允许在相同作用域内，重复声明同一个变量。
			function (){
				let a=1;
				var a=2;
			}
			
			function (){
				let a=2;
				let a=3;
			}
		 * */

		</script>
	</body>
</html>
